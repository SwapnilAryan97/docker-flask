{% extends "base.html" %}
{% block content %}

    <h1>Docker</h1>
    <p>
        Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in
        packages called containers. The service has both free and premium tiers. The software that hosts the containers
        is called Docker Engine.
    </p>
    <p>
        Docker can package an application and its dependencies in a virtual container that can run on any Linux,
        Windows, or macOS computer. This enables the application to run in a variety of locations, such as on-premises,
        in public or private cloud. When running on Linux, Docker uses the resource isolation features of the Linux
        kernel (such as cgroups and kernel namespaces) and a union-capable file system (such as OverlayFS) to allow
        containers to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual
        machines. Docker on macOS uses a Linux virtual machine to run the containers.<br>
        Because Docker containers are lightweight, a single server or virtual machine can run several containers
        simultaneously.
    </p>
    <p>
        The Linux kernel's support for namespaces mostly isolates an application's view of the operating
        environment, including process trees, network, user IDs and mounted file systems, while the kernel's cgroups
        provide resource limiting for memory and CPU.
    </p>
    <p>
        Docker implements a high-level API to provide lightweight containers that run processes in isolation. Docker
        containers are standard processes, so it is possible to use kernel features to monitor their execution --
        including for example the use of tools like strace to observe and intercede with system calls
    </p>

    <h4>Containers</h4>
    <p>
        A container is a standard unit of software that packages up code and all its dependencies so the application
        runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight,
        standalone, executable package of software that includes everything needed to run an application: code, runtime,
        system tools, system libraries and settings.
    </p>
    <p>
        Container images become containers at runtime and in the case of Docker containers - images become containers
        when they run on Docker Engine. Available for both Linux and Windows-based applications, containerized software
        will always run the same, regardless of the infrastructure. Containers isolate software from its environment and
        ensure that it works uniformly despite differences for instance between development and staging.
    </p>

    <h4>Images</h4>
    <p>
        A Docker image is a read-only template that contains a set of instructions for creating a container that can run
        on the Docker platform. It provides a convenient way to package up applications and preconfigured server
        environments, which you can use for your own private use or share publicly with other Docker users. Docker
        images are also the starting point for anyone using Docker for the first time.
    </p>
    <h6>Anatomy of a Docker Image</h6>
    <p>
        A Docker image is made up of a collection of files that bundle together all the essentials – such as
        installations, application code, and dependencies – required to configure a fully operational container
        environment. You can create a Docker image by using one of two methods:
    <ul>
        <li>
            <b>Interactive:</b> By running a container from an existing Docker image, manually changing that container
            environment through a series of live steps, and saving the resulting state as a new image.
        </li>
        <li>
            <b>Dockerfile:</b> By constructing a plain-text file, known as a Dockerfile, which provides the
            specifications for
            creating a Docker image.
        </li>
    </ul>
    </p>

    <h4>Tools</h4>
    <p>
    <ul>
        <li>
            <b>Docker Compose</b> is a tool for defining and running multi-container Docker applications. It uses YAML
            files to configure the application's services and performs the creation and start-up process of all the
            containers with a single command. <br>The <b>docker-compose</b> CLI utility allows users to run commands on
            multiple
            containers at once, for example, building images, scaling containers, running containers that were stopped,
            and more. Commands related to image manipulation, or user-interactive options, are not relevant in
            Docker Compose because they address one container.<br>The <b>docker-compose.yml</b> file is used to define
            an
            application's services and includes various configuration options. For example, the build option defines
            configuration options such as the Dockerfile path, the command option allows one to override default Docker
            commands, and more.
        </li>
        <li>
            <b>Docker Swarm </b>provides native clustering functionality for Docker containers, which turns a group of
            Docker
            engines into a single virtual Docker engine. In Docker 1.12 and higher, Swarm mode is integrated with
            Docker Engine. The <b>docker swarm CLI</b> utility allows users to run Swarm containers, create discovery
            tokens, list nodes in the cluster, and more.
        </li>
        <li>
            <b>Docker Volume</b> facilitates the independent persistence of data, allowing data to remain even after the
            container is deleted or re-created.
        </li>
    </ul>
    </p>

    <h4>Docker Commands</h4>
    <p>

    </p>

    <h4>How to start the docker project using terminal</h4>
    <p>
    <ol>
        <li>
            Open terminal in the root folder location of the project.
        </li>
        <li>
            Run the command:
            <pre><code>$ docker compose up --build</code></pre>
        </li>
        <li>You will see the container build, which should look something like this:
            <pre><code>(base) swapnilsinha@Swapnils-MacBook-Pro docker_flask_2% docker compose up --build
[+] Building 1.8s (11/11) FINISHED
 => [internal] load build definition from Dockerfile                       0.1s
 => => transferring dockerfile: 32B                                        0.0s
 => [internal] load .dockerignore                                          0.1s
 => => transferring context: 34B                                           0.0s
 => [internal] load metadata for docker.io/library/python:3.8-buster       1.2s
 => [auth] library/python:pull token for registry-1.docker.io              0.0s
 => [internal] load build context                                          0.1s
 => => transferring context: 73.27kB                                       0.1s
 => [1/5] FROM docker.io/library/python:3.8-buster@sha256:f71ea6cc6e2d5c2  0.0s
 => => resolve docker.io/library/python:3.8-buster@sha256:f71ea6cc6e2d5c2  0.0s
 => CACHED [2/5] COPY requirements.txt .                                   0.0s
 => CACHED [3/5] RUN apt-get update &&    /usr/local/bin/python3 -m pip i  0.0s
 => CACHED [4/5] WORKDIR /home/myuser                                      0.0s
 => [5/5] COPY --chown=myuser:myuser . .                                   0.2s
 => exporting to image                                                     0.1s
 => => exporting layers                                                    0.1s
 => => writing image sha256:283895504565f1c8afb5bb097e273f48e5ed09d42faa2  0.0s
 => => naming to docker.io/library/docker_flask_flask                      0.0s
[+] Running 1/1
 ⠿ Container docker_flask-flask-1  Rec...                                  2.3s
Attaching to docker_flask-flask-1
docker_flask-flask-1  |  * Serving Flask app 'app' (lazy loading)
docker_flask-flask-1  |  * Environment: development
docker_flask-flask-1  |  * Debug mode: on
docker_flask-flask-1  |  * Running on all addresses.
docker_flask-flask-1  |    WARNING: This is a development server. Do not use it in a production deployment.
docker_flask-flask-1  |  * Running on http://172.20.0.2:5000/ (Press CTRL+C to quit)
docker_flask-flask-1  |  * Restarting with stat
docker_flask-flask-1  |  * Debugger is active!
docker_flask-flask-1  |  * Debugger PIN: 581-910-567

</code></pre>

        </li>
        <li>
            Open your browser and type "localhost", and you should see your web application hosted on your local
            machine.
        </li>
        <li>
            Login to heroku on your web browser, open your app container and click on open app then you can see your web
            app hosted on the heroku server.
        </li>
    </ol>
    <h4>Other Docker commands</h4>
    <ol>
        <li>
            To view all docker containers on your machine, run:
            <pre><code>$ docker ps</code></pre>
            Where ps stands for Process Status<br><br>
        </li>
        <li>
            If you want to start docker on a specific port on your machine, run:
            <pre><code>$ docker run -dp 80:80 docker/docker_flask_2</code></pre>
            You’ll notice a few flags being used. Here’s some more info on them:
            <ul>
                <li>-d <- run the container in detached mode (in the background)</li>
                <li>-p 80:80 <- map port 80 of the host to port 80 in the container</li>
                <li>docker/getting-started <- the image to use</li>
            </ul>
        </li>
        <li>
            To build an updated version of the image:
            <pre><code>$ docker build -t  .</code></pre>
            <ul>
                <li>the -t flag tags our image.</li>
            </ul>
        <li>
            To start a new container,
            <pre><code>$ docker run -dp 3000:3000 docker_flask_2</code></pre>
        </li>
        <li>
            Use the docker stop command to stop the container.
            <pre><code>$ docker stop [the-container-id]</code></pre>
        </li>
        <li>
            Once the container has stopped, you can remove it by using the "docker rm" command.
            <pre><code>$docker rm [the-container-id]</code></pre>

        </li>
        <li>
            If you want to kill a container, run:
            <pre><code>$ docker kill [ContainerID]</code></pre>
        </li>
        <li>
            You can kill multiple containers like this:
            <pre><code>$ docker kill [ContainerID] [ContainerID] [ContainerID]</code></pre>
        </li>
    </ol>

    </p>


    <h4>Project Repository</h4>
    <a href="https://hub.docker.com/repository/docker/swapnilsinha/docker_flask_app">Swapnil's Docker Repository</a>

{% endblock %}